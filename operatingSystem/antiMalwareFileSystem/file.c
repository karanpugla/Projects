/*
* Copyright (c) 1998-2014 Erez Zadok
* Copyright (c) 2009	   Shrikar Archak
* Copyright (c) 2003-2014 Stony Brook University
* Copyright (c) 2003-2014 The Research Foundation of SUNY
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/

#include "amfs.h"
#include "common.h"
#include <linux/byteorder/generic.h>

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 __user * current_dir;
	struct linux_dirent64 __user * previous;
	int count;
	int error;
};
struct linux_dirent64 {
	u64     d_ino;
	s64     d_off;
	unsigned short  d_reclen;
	unsigned char   d_type;
	char        d_name[0];
};
struct linux_dirent {
	unsigned long   d_ino;
	unsigned long   d_off;
	unsigned short  d_reclen;
	char        d_name[1];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent __user * current_dir;
	struct linux_dirent __user * previous;
	int count;
	int error;
};


static ssize_t amfs_read(struct file *file, char __user *buf,
						size_t count, loff_t *ppos)
{
	int err,len,isquarantined;
	struct file *lower_file;
	struct dentry *dentry = file->f_path.dentry;
	struct amfs_sb_info *amfs_sb;
	struct timeval quarantinetime;
	char *amfs_buf=NULL;
	mm_segment_t old_fs;
	
	printk(KERN_INFO "amfs: read request for %d bytes.\n",count);
		lower_file = amfs_lower_file(file);
	amfs_sb=AMFS_SB(dentry->d_sb);

	isquarantined = vfs_getxattr(lower_file->f_path.dentry,"user.Q",
								(char *)&quarantinetime.tv_sec,
	sizeof(quarantinetime.tv_sec));
	if (isquarantined > 0) {
		quarantinetime.tv_sec = ntohl(quarantinetime.tv_sec);
		printk(KERN_INFO "amfs: file %s was quarantined at epoch time %ld.\n",
				lower_file->f_path.dentry->d_name.name,quarantinetime.tv_sec);

		printk(KERN_INFO "amfs: Reject read.\n");
		err = -EBADF;
		goto out;
	}
	amfs_buf = (char *)vzalloc(count);
	if( !amfs_buf ) {
		err = -EFAULT;
		printk(KERN_ERR "amfs: cannot allocate memory for buffer.\n");
			goto out;
	}
	old_fs = get_fs();
	set_fs(get_ds());
	len = vfs_read(lower_file, amfs_buf, count, ppos);
	set_fs(old_fs);

	if( len<0 ) {
		err=len;
		printk(KERN_ERR "amfs: cannot read into buffer.\n");
		goto out;
	}
	else {
		if( (err = amfs_check_for_malware_and_quarantine(lower_file,amfs_sb,amfs_buf,len,1)) ) {
			printk(KERN_ERR "amfs: read operation cancelled.\n");
			goto out;
		}
		
		err = len;
		/* update our inode atime upon a successful lower read */
		if ( err >= 0 )
			fsstack_copy_attr_atime(dentry->d_inode,
		file_inode(lower_file));

		printk(KERN_INFO "amfs: read proceed. No pattern matched.\n");

		if( copy_to_user(buf,amfs_buf,len) ) {
			err=-EFAULT;
			printk(KERN_ERR "amfs: cannot copy to user buf.\n");
			goto out;
		}
	}
	
out:
	if( amfs_buf &&!IS_ERR(amfs_buf) )
		vfree(amfs_buf);

	return err;
}

static ssize_t amfs_write(struct file *file, const char __user *buf,
size_t count, loff_t *ppos)
{
	int err, isquarantined;
	
	struct file *lower_file;
	struct dentry *dentry = file->f_path.dentry;
	struct amfs_sb_info *amfs_sb;
	struct timeval quarantinetime;
	char *amfs_buf = NULL;
	
	printk(KERN_INFO "amfs: write request for %d bytes.\n", count);
		lower_file = amfs_lower_file(file);
	amfs_sb = AMFS_SB(dentry->d_sb);

	isquarantined = vfs_getxattr(lower_file->f_path.dentry, "user.Q",
	(char *)&quarantinetime.tv_sec,
	sizeof(quarantinetime.tv_sec));
	if( isquarantined > 0 ) {
		quarantinetime.tv_sec = ntohl(quarantinetime.tv_sec);
		printk(KERN_INFO "amfs: file %s was quarantined at epoch time %ld.\n",
			lower_file->f_path.dentry->d_name.name, quarantinetime.tv_sec);

		printk(KERN_INFO "amfs:  Reject write.\n");
		err = -EBADF;
		goto out;
	}
	amfs_buf = (char *)vzalloc(count);
	if( !amfs_buf ) {
		err=-EFAULT;
		printk(KERN_ERR "amfs: cannot allocate memory for buffer.\n");
			goto out;
	}
	
	if( copy_from_user(amfs_buf, buf, count) ) {
		err=-EFAULT;
		printk("amfs: cannot copy buf from user.\n");
		goto out;
	}
	
	if( (err = amfs_check_for_malware_and_quarantine(lower_file, amfs_sb, amfs_buf, count, 1)) )
	{
		printk(KERN_ERR "amfs: write operation cancelled.\n");
		goto out;
	}

	err = vfs_write(lower_file, buf, count, ppos);
	/* update our inode times+sizes upon a successful lower write */
	if ( err >= 0 ) {
		fsstack_copy_inode_size(dentry->d_inode,
			file_inode(lower_file));
		fsstack_copy_attr_times(dentry->d_inode,
			file_inode(lower_file));
	}
	printk(KERN_INFO "amfs: write proceed. No pattern matched err=%d.\n",err);

	out:
	if( amfs_buf &&!IS_ERR(amfs_buf) )
		vfree(amfs_buf);
	return err;
}
static int amfs_filldir64(struct dir_context *ctx, const char *name, int namlen,
							loff_t offset, u64 ino, unsigned int d_type)
{
	struct linux_dirent64  *dirent;
	struct getdents_callback64 *buf =
					container_of(ctx, struct getdents_callback64, ctx);
	int reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1,
	sizeof(u64));

	printk(KERN_INFO "amfs: in amfs_filldir64.\n");

	buf->error = -EINVAL;   /* only used if we fail.. */
	if ( reclen > buf->count )
		return -EINVAL;
	dirent = buf->previous;
	if ( dirent ) {
		memcpy(&dirent->d_off, &offset, sizeof(dirent->d_off));
	}
	dirent = buf->current_dir;
//	printk(KERN_INFO "amfs: dirent=%p\n", dirent);
	memcpy(&dirent->d_ino, &ino, sizeof(ino));

//	printk(KERN_INFO "amfs: dirent->d_ino=%lu\n", (unsigned long)dirent->d_ino);
	
	
	memset(&dirent->d_off, 0, sizeof(dirent->d_off));
//	printk(KERN_INFO "amfs: dirent->d_off=%ld\n", (long)dirent->d_off);

	memcpy(&dirent->d_reclen, &reclen, sizeof(dirent->d_reclen));
//	printk(KERN_INFO "amfs: dirent->d_reclen=%hu\n", dirent->d_reclen);

	memcpy(&dirent->d_type, &d_type, sizeof(dirent->d_type));
//	printk(KERN_INFO "amfs: dirent->d_type=%u\n", dirent->d_type);

	memcpy(dirent->d_name, name, namlen);

	memset(dirent->d_name + namlen, 0, 1);
	printk(KERN_INFO "amfs: namelen=%d dirent->d_name=%s\n", namlen, dirent->d_name);

	buf->previous = dirent;
	dirent = (void  *)dirent + reclen;
	buf->current_dir = dirent;
	buf->count -= reclen;
	return 0;
}

static int amfs_readdir(struct file *file, struct dir_context *ctx)
{
	int err, offset = 0, rbytes, isdir = 0;
	unsigned char *c;
	struct timeval tv;
	char dirpath[256];
	char *abspathptr = NULL;
	struct dentry *xattrdentry = NULL;
	struct file *lower_file = NULL;
	struct dentry *dentry = file->f_path.dentry;
	struct linux_dirent64 __user *dirent;
	struct linux_dirent64  *kdirent = NULL;
	struct linux_dirent64  *d = NULL;
	struct getdents_callback64 *buf = container_of(ctx, struct getdents_callback64, ctx);
	int count;
	struct qstr name;
	struct getdents_callback64 amfs_buf = {
		.ctx.actor = amfs_filldir64
	};


	printk(KERN_INFO "amfs: readdir \n");


	dirent = buf->current_dir;
	count = buf->count;
	if( !(kdirent = vzalloc(count)) ) {
		printk(KERN_ERR "amfs: vmalloc err.\n ");
		err =- EFAULT;
		goto out;
	}
	else {
		amfs_buf.current_dir = kdirent;
		amfs_buf.count = count;
	}

	//printk(KERN_INFO " count=%d, user ptr=%p kernel ptr=%p.\n", count, dirent, kdirent);

	lower_file = amfs_lower_file(file);

	err = iterate_dir(lower_file, &amfs_buf.ctx);
	//printk(KERN_INFO " count=%d, kernel ptr=%p.\n", amfs_buf.count, kdirent);

	printk(KERN_INFO " err=%d.\n", err);
	rbytes = count-amfs_buf.count;
	printk(KERN_INFO " rbytes=%d.\n", rbytes);
	c = (char *) kdirent;
	if( err >= 0 ) {
		abspathptr=d_path( &file->f_path, dirpath, 256);
		printk(KERN_INFO "amfs: abspath=%s\n", abspathptr);
		for (offset = 0; offset < rbytes ;) {
			isdir = 0;
			xattrdentry = NULL;
			d = (struct linux_dirent64 *) (c + offset);
			//printk(KERN_INFO "amfs: d=%p  offset=%d\n", d, offset);
			name.name = d->d_name;
			name.len = strlen(d->d_name);

			printk(KERN_INFO "amfs: dirent_name=%s\n", d->d_name);
			printk(KERN_INFO "amfs: indirenpath=%s/%s\n", abspathptr,d->d_name);

			if( d->d_type != DT_DIR ) {
				/*xattrdentry=lookup_one_len(d->d_name,dentry,strlen(d->d_name));*/
				xattrdentry = lookup_one_len(d->d_name, lower_file->f_path.dentry, strlen(d->d_name));
				if( xattrdentry && IS_ERR(xattrdentry) ) {
					err = -EINVAL;
					printk(KERN_ERR "amfs: cannot get xattrdentry %s/%s.\n", abspathptr,d->d_name);
					goto out;
				}
				printk(KERN_INFO "amfs:  xattrdentry name=%s.\n", xattrdentry->d_name.name);
			}
			else
				isdir = 1;


			printk(KERN_ERR "amfs: isdir=%d or filepath obtained.\n", isdir);
			if( isdir || vfs_getxattr(xattrdentry, "user.Q", &tv.tv_sec, sizeof(tv.tv_sec)) < 0 ) {
				printk(KERN_INFO "amfs: No Xatrr. dirent is clean.\n");
				ctx->actor(ctx, name.name, name.len, d->d_off, d->d_ino, d->d_type);
			}
			else {
				printk(KERN_INFO "amfs: dirent %s is malicious.Skip\n", d->d_name);
			}

			offset += d->d_reclen;
		}
	}

	printk(KERN_ERR "amfs: exit .\n");

	file->f_pos = lower_file->f_pos;
	if ( err >= 0 )		/* copy the atime */
		fsstack_copy_attr_atime(dentry->d_inode,
								file_inode(lower_file));

out:
	if( kdirent && !IS_ERR(kdirent) )
		vfree(kdirent);

	printk(KERN_ERR "amfs: readdir exit .\n");
	return err;
}

static long amfs_unlocked_ioctl(struct file *file, unsigned int cmd,
unsigned long arg)
{
	long err = -ENOTTY;
	struct file *lower_file;
	struct amfs_sb_info *amfs_sb;
	struct timeval tv;
	amfs_pattern_t upatt;
	int i, rc, freeslot = -1;
	
	printk(KERN_INFO "amfs: In ioctl cmd=%x, AMFS_GETPATTERNS=%x,AMFS_SETPATTERN=%x,AMFS_DELPATTERN=%x\n",
						cmd, AMFS_GETPATTERNS, AMFS_SETPATTERN, AMFS_DELPATTERN);

	amfs_sb = AMFS_SB(file->f_path.dentry->d_sb);

	if( ! arg ) {
		err = -EFAULT;
		printk(KERN_ERR "amfs: arg to ioctl NULL\n");
		goto out;
	}

	switch(cmd)
	{
		case AMFS_GETPATTERNS:
		printk(KERN_INFO "amfs: ioctl is AMFS_GETPATTERNS\n");
		if( (err = (copy_to_user((void *)arg, amfs_sb->patterns, sizeof(amfs_sb->patterns)))) ) {
			err = -EFAULT;
			printk(KERN_ERR "amfs: Cannot copy patterns to user buffer\n");
		}
		else
			printk(KERN_INFO "amfs: Copied %d bytes to user buffer\n" ,sizeof(amfs_sb->patterns));
		
		goto out;
		break;
		
		case AMFS_SETPATTERN:
		printk(KERN_INFO "amfs: ioctl is AMFS_SETPATTERN\n");
		rc=strncpy_from_user(upatt,(char *)arg, 256);
		if( rc <= 0 ) {
			printk(KERN_ERR "amfs: Cannot copy pattern from user\n");
			err = -EFAULT;
			goto out;
		}
		upatt[255] = '\0';
		for(i=0; i < 256; i++) {
			if( amfs_sb->patterns[i][0] == -1 ) {
				if(freeslot == -1)
				freeslot=i;
			}
			else {
				if( strncmp(amfs_sb->patterns[i], upatt, 256) == 0 ) {
					printk(KERN_ERR "amfs: Pattern %s already exists.\n" ,upatt);
					err = -EEXIST;
					goto out;
				}
			}
		}

		if( freeslot == -1 ) {
			printk(KERN_INFO "amfs:  Cannot register more than 256 patterns into superblock\n");
			err = -ENOSPC;
		}
		else {
			strncpy(amfs_sb->patterns[freeslot], upatt, 256);
			amfs_sb->patterns[freeslot][254] = '\0';
			amfs_sb->patterns[freeslot][255] = strlen(upatt);
			printk(KERN_INFO "amfs: Copied pattern %s  of len=%d into superblock\n" ,
						amfs_sb->patterns[freeslot], amfs_sb->patterns[freeslot][255]);
			
			do_gettimeofday(&tv);
			amfs_sb->patterndb_mtime = tv.tv_sec;
			printk(KERN_INFO "amfs: Patterndb modified at epoch time %ld.\n",amfs_sb->patterndb_mtime);

			if( (err = amfs_update_patterndb_file(amfs_sb)) )
				printk(KERN_ERR "amfs: But Cannot update patterndb file.\n");
		}

		goto out;
		break;

		case AMFS_DELPATTERN:
		printk(KERN_INFO "amfs: ioctl is AMFS_DELPATTERN\n");
		rc = strncpy_from_user(upatt,(char *)arg, 256);
		if( rc <= 0 ) {
			printk(KERN_ERR "amfs: Cannot copy pattern from user\n");
			err = -EFAULT;
			goto out;
		}
		upatt[255] = '\0';
		for(i = 0; i < 256; i++)
		{
			if( amfs_sb->patterns[i][0] != -1 && strncmp(amfs_sb->patterns[i], upatt, 256) == 0 ) {
				amfs_sb->patterns[i][0] = -1;
				printk(KERN_ERR "amfs: Pattern %s deleted.\n" ,upatt);
				err = 0;
				do_gettimeofday(&tv);
				amfs_sb->patterndb_mtime = tv.tv_sec;
				printk(KERN_INFO "amfs: Patterndb modified at epoch time %ld.\n", amfs_sb->patterndb_mtime);
				if( (err = amfs_update_patterndb_file(amfs_sb)) )
				printk(KERN_ERR "amfs: But Cannot update patterndb file.\n");
				goto out;
			}
		}

		printk(KERN_ERR "amfs: Pattern %s is not registered.\n", upatt);
		err = -ENOENT;

		goto out;
		break;

	}
	

	lower_file = amfs_lower_file(file);

	/* XXX: use vfs_ioctl if/when VFS exports it */
	if ( !lower_file || !lower_file->f_op )
		goto out;
	if ( lower_file->f_op->unlocked_ioctl )
		err = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);
	
	/* some ioctls can change inode attributes (EXT2_IOC_SETFLAGS) */
	if ( !err )
		fsstack_copy_attr_all(file_inode(file),
	file_inode(lower_file));
out:
	return err;
}

#ifdef CONFIG_COMPAT
static long amfs_compat_ioctl(struct file *file, unsigned int cmd,
unsigned long arg)
{
	long err = -ENOTTY;
	struct file *lower_file;
	
	lower_file = amfs_lower_file(file);
	
	/* XXX: use vfs_ioctl if/when VFS exports it */
	if (!lower_file || !lower_file->f_op)
		goto out;
	if (lower_file->f_op->compat_ioctl)
		err = lower_file->f_op->compat_ioctl(lower_file, cmd, arg);
	
	out:
	return err;
}
#endif

static int amfs_mmap(struct file *file, struct vm_area_struct *vma)
{
	int err = 0;
	bool willwrite;
	struct file *lower_file;
	const struct vm_operations_struct *saved_vm_ops = NULL;
	
	/* this might be deferred to mmap's writepage */
	willwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);
	
	/*
	* File systems which do not implement ->writepage may use
	* generic_file_readonly_mmap as their ->mmap op.  If you call
	* generic_file_readonly_mmap with VM_WRITE, you'd get an -EINVAL.
	* But we cannot call the lower ->mmap op, so we can't tell that
	* writeable mappings won't work.  Therefore, our only choice is to
	* check if the lower file system supports the ->writepage, and if
	* not, return EINVAL (the same error that
	* generic_file_readonly_mmap returns in that case).
	*/
	lower_file = amfs_lower_file(file);
	if (willwrite && !lower_file->f_mapping->a_ops->writepage) {
		err = -EINVAL;
		printk(KERN_ERR "amfs: lower file system does not "
		"support writeable mmap\n");
		goto out;
	}
	
	/*
	* find and save lower vm_ops.
	*
	* XXX: the VFS should have a cleaner way of finding the lower vm_ops
	*/
	if (!AMFS_F(file)->lower_vm_ops) {
		err = lower_file->f_op->mmap(lower_file, vma);
		if (err) {
			printk(KERN_ERR "amfs: lower mmap failed %d\n", err);
			goto out;
		}
		saved_vm_ops = vma->vm_ops; /* save: came from lower ->mmap */
	}
	
	/*
	* Next 3 lines are all I need from generic_file_mmap.  I definitely
	* don't want its test for ->readpage which returns -ENOEXEC.
	*/
	file_accessed(file);
	vma->vm_ops = &amfs_vm_ops;
	
	file->f_mapping->a_ops = &amfs_aops; /* set our aops */
	if (!AMFS_F(file)->lower_vm_ops) /* save for our ->fault */
		AMFS_F(file)->lower_vm_ops = saved_vm_ops;
	
	out:
	return err;
}

static int amfs_open(struct inode *inode, struct file *file)
{
	int err = 0;
	struct file *lower_file = NULL;
	struct path lower_path;
	int isquarantined;
	struct timeval quarantinetime;
	#ifdef EXTRA_CREDIT
	int len,rescan=0;
	loff_t ppos=0;
	loff_t scanpos=0;
	char *buf = NULL;
	struct amfs_sb_info *amfs_sb;
	mm_segment_t old_fs;
	
	#endif
	printk(KERN_INFO "amfs: open for inode=%lu with file=%s.\n",inode->i_ino,file->f_path.dentry->d_name.name);
		/* don't open unhashed/deleted files */
	if (d_unhashed(file->f_path.dentry)) {
		err = -ENOENT;
		goto out_err;
	}
	
	file->private_data =
	kzalloc(sizeof(struct amfs_file_info), GFP_KERNEL);
	if (!AMFS_F(file)) {
		err = -ENOMEM;
		goto out_err;
	}
	
	/* open lower object and link amfs's file struct to lower's */
	amfs_get_lower_path(file->f_path.dentry, &lower_path);
	
	if( !S_ISDIR(lower_path.dentry->d_inode->i_mode) )
	{
		printk(KERN_INFO "amfs: file is not directory, check.\n");
		isquarantined=vfs_getxattr(lower_path.dentry,"user.Q",
		(char *)&quarantinetime.tv_sec,
		sizeof(quarantinetime.tv_sec));
		
		if(isquarantined>0)
		{
			#ifdef EXTRA_CREDIT
			printk(KERN_INFO "amfs: EXTRA_CREDIT file is quarantined. See if patterndb was updated.\n");
			quarantinetime.tv_sec=ntohl(quarantinetime.tv_sec);
			if(quarantinetime.tv_sec < AMFS_SB(inode->i_sb)->patterndb_mtime )
			{
				printk(KERN_INFO "amfs: EXTRA_CREDIT Patterndb updated since file was quarantined. Re-scan.\n");
				rescan=1;
			}
			else
			{
				printk(KERN_INFO "amfs: EXTRA_CREDIT Patterndb not updated since file was quarantined. Reject open.\n");
				printk(KERN_ERR "amfs: file is quarantined. Reject open.\n");
				lower_file=ERR_PTR(-ENOENT);
			}
			#else
				printk(KERN_ERR "amfs: file is quarantined. Reject open.\n");
			lower_file=ERR_PTR(-ENOENT);
			#endif
		}
		if(isquarantined < 0
		#ifdef EXTRA_CREDIT
		|| rescan==1
		#endif
		
		)
		
		{
			#ifdef EXTRA_CREDIT
			printk(KERN_INFO "amfs: EXTRA_CREDIT Not quarantined or rescan=%d.\n",rescan);
			lower_file = dentry_open(&lower_path, O_RDONLY, current_cred());
			if (IS_ERR(lower_file))
			{
				printk(KERN_ERR "amfs: EXTRA_CREDIT cannot dentry_open.\n");
				goto open_err;
			}
			
			if( !(buf=vzalloc(2*PAGE_SIZE+1)) )
			{
				printk(KERN_ERR "amfs: EXTRA_CREDIT cannot vzalloc buf.\n");
				goto extra_credit_err;
				
			}
			old_fs = get_fs();
			set_fs(get_ds());
			len = vfs_read(lower_file, buf, 2*PAGE_SIZE, &ppos);
			set_fs(old_fs);
			if(len<0)
			{
				err=-EFAULT;
				printk(KERN_ERR "amfs:EXTRA_CREDIT cannot read into buffer len=%d.\n",len);
				goto extra_credit_err;
			}
			
			else if( len==0 )
			{
				printk(KERN_INFO "amfs:EXTRA_CREDIT file empty. No harm open it.\n");
				goto success;
				
			}
			amfs_sb=AMFS_SB(file->f_path.dentry->d_sb);
			
			do
			{
				printk(KERN_INFO "amfs:EXTRA_CREDIT wlen=%d. \n",len);
				
				if( amfs_check_for_malware_and_quarantine(lower_file, amfs_sb,
				buf,(len > PAGE_SIZE) ? PAGE_SIZE : len , 1 ) < 0 )
				{
					printk(KERN_INFO "amfs:EXTRA_CREDIT Malicious open. Reject.\n");
					printk(KERN_INFO "amfs:EXTRA_CREDIT m %c %c .\n",buf[0],buf[(len > PAGE_SIZE) ? PAGE_SIZE -1 : len-1]);
					goto extra_credit_err;
				}
				
				if ( len > PAGE_SIZE )
				{
					printk(KERN_INFO "amfs:EXTRA_CREDIT  l %c %c.\n",buf[0],buf[PAGE_SIZE-1]);
					printk(KERN_INFO "amfs:EXTRA_CREDIT scanpos=%lu.\n",(unsigned long)scanpos);
					scanpos+=PAGE_SIZE-254;
					ppos=scanpos;
					printk(KERN_INFO "amfs:EXTRA_CREDIT after scanpos=%lu.\n",(unsigned long)scanpos);
					old_fs = get_fs();
					set_fs(get_ds());
					len = vfs_read(lower_file, buf, 2*PAGE_SIZE+1, &ppos);
					printk(KERN_INFO "amfs:EXTRA_CREDIT e2len=%d. \n",len);
					set_fs(old_fs);
					if(len<0)
					{
						err=-EFAULT;
						printk(KERN_ERR "amfs:EXTRA_CREDIT cannot read into buffer.\n");
						goto extra_credit_err;
					}
				}
				else
					break;
				
			}while ( len > 0);
			//printk(KERN_INFO "amfs:EXTRA_CREDIT outwhile count=%d.\n",count);
			
			success:
			if(rescan)
			{
				printk(KERN_INFO "amfs:EXTRA_CREDIT file was quarantined but now clean. remove xattr \n");
				if(vfs_removexattr(lower_file->f_path.dentry,"user.Q") < 0 )
				{
					printk(KERN_INFO "amfs:EXTRA_CREDIT cannot remove xattr \n");
					
				}
				
			}
			printk(KERN_INFO "amfs:EXTRA_CREDIT file is clean. Open. len=%d. \n",len);
			fput(lower_file);
			lower_file = dentry_open(&lower_path, file->f_flags, current_cred());
			goto extra_credit_out;
			
			
			extra_credit_err:
			if(lower_file && !IS_ERR(lower_file))
			{
				printk(KERN_INFO "amfs:EXTRA_CREDIT extra_credit_err. \n");
				fput(lower_file);
				lower_file=ERR_PTR(-ENOENT);
			}
			
			extra_credit_out:
			printk(KERN_INFO "amfs:EXTRA_CREDIT extra_credit_out. \n");
			if(buf && !IS_ERR(buf))
			vfree(buf);
			
			#else
				lower_file = dentry_open(&lower_path, file->f_flags, current_cred());
			#endif
		}
	}
	else
	{
		printk(KERN_INFO "amfs: file is directory, skip check.\n");
		lower_file = dentry_open(&lower_path, file->f_flags, current_cred());
		
	}
	
	#ifdef EXTRA_CREDIT
	open_err:
	#endif
	path_put(&lower_path);
	if (IS_ERR(lower_file)) {
		err = PTR_ERR(lower_file);
		lower_file = amfs_lower_file(file);
		if (lower_file) {
			printk(KERN_INFO "amfs:EXTRA_CREDIT if lower_file: . \n");
			amfs_set_lower_file(file, NULL);
			fput(lower_file); /* fput calls dput for lower_dentry */
		}
	} else {
		printk(KERN_INFO "amfs:EXTRA_CREDIT :!IS_ERR(lower_file) . \n");
		amfs_set_lower_file(file, lower_file);
	}
	
	
	if (err)
		kfree(AMFS_F(file));
	else
		fsstack_copy_attr_all(inode, amfs_lower_inode(inode));
	
	out_err:
	return err;
}

static int amfs_flush(struct file *file, fl_owner_t id)
{
	int err = 0;
	struct file *lower_file = NULL;
	#ifdef EXTRA_CREDIT
	int len=0;
	loff_t ppos=0;
	loff_t scanpos=0;
	char *buf = NULL;
	struct amfs_sb_info *amfs_sb;
	struct file *rdonlylower_file = NULL;
	mm_segment_t old_fs;
	
	#endif
	
	printk(KERN_INFO "amfs: in amfs_flush\n");
	lower_file = amfs_lower_file(file);
	
	#ifdef EXTRA_CREDIT
	if( !S_ISDIR(lower_file->f_path.dentry->d_inode->i_mode) )
	{
		printk(KERN_INFO "amfs: file is not directory, check.\n");
		if ( !lower_file )
		{
			printk(KERN_ERR "amfs: EXTRA_CREDIT no lower file.\n");
			goto out;
		}
		rdonlylower_file=dentry_open(&lower_file->f_path, O_RDONLY, current_cred());
		if( IS_ERR(rdonlylower_file) )
		{
			printk(KERN_ERR "amfs: EXTRA_CREDIT cannot open lower file rdonly.\n");
			goto out;
		}
		
		if( !(buf=vzalloc(2*PAGE_SIZE+1)) )
		{
			printk(KERN_ERR "amfs: EXTRA_CREDIT cannot vzalloc buf.\n");
			goto extra_credit_out;
			
		}
		old_fs = get_fs();
		set_fs(get_ds());
		len = vfs_read(rdonlylower_file, buf, 2*PAGE_SIZE, &ppos);
		set_fs(old_fs);
		if(len<0)
		{
			printk(KERN_ERR "amfs:EXTRA_CREDIT cannot read into buffer len=%d.\n",len);
			goto extra_credit_out;
		}
		
		else if( len==0 )
		{
			printk(KERN_INFO "amfs:EXTRA_CREDIT file empty. No harm close it without scan.\n");
			goto extra_credit_out;
			
		}
		amfs_sb=AMFS_SB(file->f_path.dentry->d_sb);
		
		do
		{
			printk(KERN_INFO "amfs:EXTRA_CREDIT wlen=%d. \n",len);
			
			if( amfs_check_for_malware_and_quarantine(rdonlylower_file, amfs_sb,
			buf,(len > PAGE_SIZE) ? PAGE_SIZE : len , 1 ) < 0 )
			{
				printk(KERN_INFO "amfs:EXTRA_CREDIT Malicious close. Mark file malicious.\n");
				printk(KERN_INFO "amfs:EXTRA_CREDIT m %c %c .\n",buf[0],buf[(len > PAGE_SIZE) ? PAGE_SIZE -1 : len-1]);
				goto extra_credit_out;
			}
			
			if ( len > PAGE_SIZE )
			{
				printk(KERN_INFO "amfs:EXTRA_CREDIT  l %c %c.\n",buf[0],buf[PAGE_SIZE-1]);
				printk(KERN_INFO "amfs:EXTRA_CREDIT scanpos=%lu.\n",(unsigned long)scanpos);
				
				/* Since patterns are not longer than 254 chars
				   re-read last 254 bytes to detect malware that crosses buffer */
				scanpos+=PAGE_SIZE-254;
				ppos=scanpos;
				printk(KERN_INFO "amfs:EXTRA_CREDIT after scanpos=%lu.\n",(unsigned long)scanpos);
				old_fs = get_fs();
				set_fs(get_ds());
				len = vfs_read(rdonlylower_file, buf, 2*PAGE_SIZE+1, &ppos);
				printk(KERN_INFO "amfs:EXTRA_CREDIT e2len=%d. \n",len);
				set_fs(old_fs);
				if(len<0)
				{
					printk(KERN_ERR "amfs:EXTRA_CREDIT cannot read into buffer.\n");
					goto extra_credit_out;
				}
			}
			else
				break;
			
		}while ( len > 0);
		//printk(KERN_INFO "amfs:EXTRA_CREDIT outwhile count=%d.\n",count);
		
		extra_credit_out:
		printk(KERN_INFO "amfs:EXTRA_CREDIT extra_credit_out. \n");
		if(rdonlylower_file && !IS_ERR(rdonlylower_file) )
		fput(rdonlylower_file);
		if(buf && !IS_ERR(buf))
		vfree(buf);
		
	}
	else
	{
		printk(KERN_INFO "amfs: file is directory, skip check.\n");
		
	}
	#endif
	
	if (lower_file && lower_file->f_op && lower_file->f_op->flush) {
		filemap_write_and_wait(file->f_mapping);
		err = lower_file->f_op->flush(lower_file, id);
	}
	#ifdef EXTRA_CREDIT
	out:
	#endif
	return err;
}

/* release all lower object references & free the file info structure */
static int amfs_file_release(struct inode *inode, struct file *file)
{
	struct file *lower_file;
	
	lower_file = amfs_lower_file(file);
	if (lower_file) {
		amfs_set_lower_file(file, NULL);
		fput(lower_file);
	}
	
	kfree(AMFS_F(file));
	return 0;
}

static int amfs_fsync(struct file *file, loff_t start, loff_t end,
int datasync)
{
	int err;
	struct file *lower_file;
	struct path lower_path;
	struct dentry *dentry = file->f_path.dentry;
	
	err = __generic_file_fsync(file, start, end, datasync);
	if (err)
		goto out;
	lower_file = amfs_lower_file(file);
	amfs_get_lower_path(dentry, &lower_path);
	err = vfs_fsync_range(lower_file, start, end, datasync);
	amfs_put_lower_path(dentry, &lower_path);
	out:
	return err;
}

static int amfs_fasync(int fd, struct file *file, int flag)
{
	int err = 0;
	struct file *lower_file = NULL;
	
	lower_file = amfs_lower_file(file);
	if (lower_file->f_op && lower_file->f_op->fasync)
		err = lower_file->f_op->fasync(fd, lower_file, flag);
	
	return err;
}

static ssize_t amfs_aio_read(struct kiocb *iocb, const struct iovec *iov,
unsigned long nr_segs, loff_t pos)
{
	int err = -EINVAL;
	struct file *file, *lower_file;
	
	file = iocb->ki_filp;
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->aio_read)
		goto out;
	/*
	* It appears safe to rewrite this iocb, because in
	* do_io_submit@fs/aio.c, iocb is a just copy from user.
	*/
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->aio_read(iocb, iov, nr_segs, pos);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode atime as needed */
	if (err >= 0 || err == -EIOCBQUEUED)
		fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
	file_inode(lower_file));
	out:
	return err;
}

static ssize_t amfs_aio_write(struct kiocb *iocb, const struct iovec *iov,
unsigned long nr_segs, loff_t pos)
{
	int err = -EINVAL;
	struct file *file, *lower_file;
	
	file = iocb->ki_filp;
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->aio_write)
		goto out;
	/*
	* It appears safe to rewrite this iocb, because in
	* do_io_submit@fs/aio.c, iocb is a just copy from user.
	*/
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->aio_write(iocb, iov, nr_segs, pos);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode times/sizes as needed */
	if (err >= 0 || err == -EIOCBQUEUED) {
		fsstack_copy_inode_size(file->f_path.dentry->d_inode,
		file_inode(lower_file));
		fsstack_copy_attr_times(file->f_path.dentry->d_inode,
		file_inode(lower_file));
	}
	out:
	return err;
}

/*
* Wrapfs cannot use generic_file_llseek as ->llseek, because it would
* only set the offset of the upper file.  So we have to implement our
* own method to set both the upper and lower file offsets
* consistently.
*/
static loff_t amfs_file_llseek(struct file *file, loff_t offset, int whence)
{
	int err;
	struct file *lower_file;
	
	err = generic_file_llseek(file, offset, whence);
	if (err < 0)
		goto out;
	
	lower_file = amfs_lower_file(file);
	err = generic_file_llseek(lower_file, offset, whence);
	
	out:
	return err;
}

/*
* Wrapfs read_iter, redirect modified iocb to lower read_iter
*/
ssize_t
amfs_read_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	int err;
	struct file *file = iocb->ki_filp, *lower_file;
	
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->read_iter) {
		err = -EINVAL;
		goto out;
	}
	
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->read_iter(iocb, iter);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode atime as needed */
	if (err >= 0 || err == -EIOCBQUEUED)
		fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
	file_inode(lower_file));
	out:
	return err;
}

/*
* Wrapfs write_iter, redirect modified iocb to lower write_iter
*/
ssize_t
amfs_write_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	int err;
	struct file *file = iocb->ki_filp, *lower_file;
	
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->write_iter) {
		err = -EINVAL;
		goto out;
	}
	
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->write_iter(iocb, iter);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode times/sizes as needed */
	if (err >= 0 || err == -EIOCBQUEUED) {
		fsstack_copy_inode_size(file->f_path.dentry->d_inode,
		file_inode(lower_file));
		fsstack_copy_attr_times(file->f_path.dentry->d_inode,
		file_inode(lower_file));
	}
	out:
	return err;
}

const struct file_operations amfs_main_fops = {
	.llseek		= generic_file_llseek,
	.read		= amfs_read,
	.write		= amfs_write,
	.unlocked_ioctl	= amfs_unlocked_ioctl,
	#ifdef CONFIG_COMPAT
	.compat_ioctl	= amfs_compat_ioctl,
	#endif
	.mmap		= amfs_mmap,
	.open		= amfs_open,
	.flush		= amfs_flush,
	.release	= amfs_file_release,
	.fsync		= amfs_fsync,
	.fasync		= amfs_fasync,
	.aio_read	= amfs_aio_read,
	.aio_write	= amfs_aio_write,
	.read_iter	= amfs_read_iter,
	.write_iter	= amfs_write_iter,
};

/* trimmed directory options */
const struct file_operations amfs_dir_fops = {
	.llseek		= amfs_file_llseek,
	.read		= generic_read_dir,
	.iterate	= amfs_readdir,
	.unlocked_ioctl	= amfs_unlocked_ioctl,
	#ifdef CONFIG_COMPAT
	.compat_ioctl	= amfs_compat_ioctl,
	#endif
	.open		= amfs_open,
	.release	= amfs_file_release,
	.flush		= amfs_flush,
	.fsync		= amfs_fsync,
	.fasync		= amfs_fasync,
};
